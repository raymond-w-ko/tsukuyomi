(ns tsukuyomi.core)

(def tget
  (fn [key table]
    (_emit_ "table[key]")))

(def tassoc!
  (fn [table key value]
    (_emit_ "table[key] = value")
    nil))

(def first
  (fn [coll]
    (.first coll)))

(def rest
  (fn [coll]
    (.rest coll)))

(def conj
  (fn [coll x]
    (.conj coll x)))

(def cons
  (fn [x seq]
    (.cons seq x)))

(def second
  (fn [cell]
    (first (rest cell))))

(def get
  (fn [map key]
    (.get map key)))

(def assoc
  (fn [map key value]
    (.assoc map key value)))

(def seq
  (fn [coll]
    (.seq coll)))

(def print
  (fn [x]
    (_emit_ "io.write(tsukuyomi.print(x))")
    (_emit_ "io.write('\\n')")
    nil
    ))

(def concat
  (fn
    ([] '()) 
    ([x]
     (if (=== x nil)
       '()
       (seq x)))
    ([x y]
     (tsukuyomi.lang.ConcatSeq/new (seq x) (seq y)))
    ))

(def
  ^{:macro true} defn
  (fn [name & forms]
   '(print "ayy, lmao")
   ))

(def count
  (fn [coll] (.count coll)))

(def ===
  (fn [x y] (_emit_ "x == y")))

(def =
  (fn [x y] (=== x y)))

(def apply
  (fn [f args]
    (let [num_args (count args)]
      (if (= num_args 0)
        (f)
        (if (= num_args 1)
          (f (first args))
          (if (= num_args 2)
            (f (first args) (second args))
            (if (= num_args 3)
              (let [arg0 (first args)
                    args (rest args)

                    arg1 (first args)
                    args (rest args)

                    arg2 (first args)]
                (f arg0 arg1 arg2)))))))))

(def list
  (fn
    ([& args] args)))

(def +
  (fn
    [x y] (_emit_ "(x + y)")))
